package visitor;

import calculator.Calculator;
import calculator.IllegalConstruction;
import calculator.numbers.Expression;
import calculator.numbers.MyNotANumber;
import calculator.numbers.MyRationalNumber;
import calculator.operators.Divides;
import calculator.operators.Minus;
import calculator.operators.Plus;
import calculator.operators.Times;
import parser.rational.RationalExprBaseVisitor;
import parser.rational.RationalExprParser;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Visitor implementation for parsing rational number expressions.
 * It defines the logic to traverse and evaluate the parse tree generated by ANTLR.
 */
public class RationalParserVisitor extends RationalExprBaseVisitor<Expression> {

    private final Calculator c;

    /**
     * Constructor for RationalParserVisitor.
     *
     * @param calculator The calculator instance used for evaluating expressions.
     */
    public RationalParserVisitor(Calculator calculator) {
        this.c = calculator;
    }

    //-------------------- INFIX ----------------------

    /**
     * Visit an infix expression with parentheses.
     *
     * @param ctx the parse tree
     * @return the evaluated expression in the parentheses
     */
    @Override
    public Expression visitParensInfix(RationalExprParser.ParensInfixContext ctx) {
        try {
            if (ctx.SUB() != null) {
                List<Expression> params = new ArrayList<>(Arrays.asList(new MyRationalNumber(-1), visit(ctx.infix())));
                return c.eval(new Times(params));
            }
            return visit(ctx.infix());
        }
        catch (IllegalConstruction e) {
            return new MyNotANumber();
        }
    }

    /**
     * Visit an infix rational number.
     *
     * @param ctx the parse tree
     * @return the evaluated rational number
     */
    @Override
    public Expression visitRationalInfix(RationalExprParser.RationalInfixContext ctx) {
        return visit(ctx.rational());
    }

    /**
     * Visit an infix expression with addition or subtraction.
     *
     * @param ctx the parse tree
     * @return the result of the addition or subtraction operation or NaN if the operation is illegal
     */
    @Override
    public Expression visitAddSubInfix(RationalExprParser.AddSubInfixContext ctx) {
        Expression number1 = visit(ctx.infix(0));
        Expression number2 = visit(ctx.infix(1));
        List<Expression> params = new ArrayList<>(Arrays.asList(number1, number2));
        try {
            if (ctx.op.getType() == RationalExprParser.ADD)
                return c.eval(new Plus(params));
            return c.eval(new Minus(params));
        }
        catch (IllegalConstruction e) {
            return new MyNotANumber();
        }
    }

    /**
     * Visit an infix expression with multiplication or division.
     *
     * @param ctx the parse tree
     * @return the result of the multiplication or division operation or NaN if the operation is illegal
     */
    @Override
    public Expression visitMulDivInfix(RationalExprParser.MulDivInfixContext ctx) {
        Expression number1 = visit(ctx.infix(0));
        Expression number2 = visit(ctx.infix(1));
        List<Expression> params = new ArrayList<>(Arrays.asList(number1, number2));
        try {
            if (ctx.op.getType() == RationalExprParser.MUL)
                return c.eval(new Times(params));
            return c.eval(new Divides(params));
        }
        catch (IllegalConstruction e) {
            return new MyNotANumber();
        }
    }

    //-------------------- PREFIX ----------------------

    /**
     * Visit a prefix expression with parentheses.
     *
     * @param ctx the parse tree
     * @return the evaluated expression in the parentheses
     */
    @Override
    public Expression visitParensPrefix(RationalExprParser.ParensPrefixContext ctx) {
        try {
            if (ctx.SUB() != null) {
                List<Expression> params = new ArrayList<>(Arrays.asList(new MyRationalNumber(-1), visit(ctx.prefix())));
                return c.eval(new Times(params));
            }
            return visit(ctx.prefix());
        }
        catch (IllegalConstruction e) {
            return new MyNotANumber();
        }
    }

    /**
     * Visit a prefix rational number.
     *
     * @param ctx the parse tree
     * @return the evaluated rational number
     */
    @Override
    public Expression visitRationalPrefix(RationalExprParser.RationalPrefixContext ctx) {
        return visit(ctx.rational());
    }

    /**
     * Visit a prefix expression with addition or subtraction.
     *
     * @param ctx the parse tree
     * @return the result of the addition or subtraction operation or NaN if the operation is illegal
     */
    @Override
    public Expression visitAddSubPrefix(RationalExprParser.AddSubPrefixContext ctx) {
        Expression number1 = visit(ctx.prefix(0));
        Expression number2 = visit(ctx.prefix(1));
        List<Expression> params = new ArrayList<>(Arrays.asList(number1, number2));
        for (int i = 2; i < ctx.prefix().size(); i++) {
            params.add(visit(ctx.prefix(i)));
        }
        try {
            if (ctx.op.getType() == RationalExprParser.ADD)
                return c.eval(new Plus(params));
            return c.eval(new Minus(params));
        }
        catch (IllegalConstruction e) {
            return new MyNotANumber();
        }
    }

    /**
     * Visit a prefix expression with multiplication or division.
     *
     * @param ctx the parse tree
     * @return the result of the multiplication or division operation or NaN if the operation is illegal
     */
    @Override
    public Expression visitMulDivPrefix(RationalExprParser.MulDivPrefixContext ctx) {
        Expression number1 = visit(ctx.prefix(0));
        Expression number2 = visit(ctx.prefix(1));
        List<Expression> params = new ArrayList<>(Arrays.asList(number1, number2));
        for (int i = 2; i < ctx.prefix().size(); i++) {
            params.add(visit(ctx.prefix(i)));
        }
        try {
            if (ctx.op.getType() == RationalExprParser.MUL)
                return c.eval(new Times(params));
            return c.eval(new Divides(params));
        }
        catch (IllegalConstruction e) {
            return new MyNotANumber();
        }
    }

    //-------------------- POSTFIX ----------------------

    /**
     * Visit a postfix expression with parentheses.
     *
     * @param ctx the parse tree
     * @return the evaluated expression in the parentheses
     */
    @Override
    public Expression visitParensPostfix(RationalExprParser.ParensPostfixContext ctx) {
        try {
            if (ctx.SUB() != null) {
                List<Expression> params = new ArrayList<>(Arrays.asList(new MyRationalNumber(-1), visit(ctx.postfix())));
                return c.eval(new Times(params));
            }
            return visit(ctx.postfix());
        }
        catch (IllegalConstruction e) {
            return new MyNotANumber();
        }
    }

    /**
     * Visit a postfix rational number.
     *
     * @param ctx the parse tree
     * @return the evaluated rational number
     */
    @Override
    public Expression visitRationalPostfix(RationalExprParser.RationalPostfixContext ctx) {
        return visit(ctx.rational());
    }

    /**
     * Visit a postfix expression with addition or subtraction.
     *
     * @param ctx the parse tree
     * @return the result of the addition or subtraction operation or NaN if the operation is illegal
     */
    @Override
    public Expression visitAddSubPostfix(RationalExprParser.AddSubPostfixContext ctx) {
        Expression number1 = visit(ctx.postfix(0));
        Expression number2 = visit(ctx.postfix(1));
        List<Expression> params = new ArrayList<>(Arrays.asList(number1, number2));
        for (int i = 2; i < ctx.postfix().size(); i++) {
            params.add(visit(ctx.postfix(i)));
        }
        try {
            if (ctx.op.getType() == RationalExprParser.ADD)
                return c.eval(new Plus(params));
            return c.eval(new Minus(params));
        }
        catch (IllegalConstruction e) {
            return new MyNotANumber();
        }
    }

    /**
     * Visit a postfix expression with multiplication or division.
     *
     * @param ctx the parse tree
     * @return the result of the multiplication or division operation or NaN if the operation is illegal
     */
    @Override
    public Expression visitMulDivPostfix(RationalExprParser.MulDivPostfixContext ctx) {
        Expression number1 = visit(ctx.postfix(0));
        Expression number2 = visit(ctx.postfix(1));
        List<Expression> params = new ArrayList<>(Arrays.asList(number1, number2));
        for (int i = 2; i < ctx.postfix().size(); i++) {
            params.add(visit(ctx.postfix(i)));
        }
        try {
            if (ctx.op.getType() == RationalExprParser.MUL)
                return c.eval(new Times(params));
            return c.eval(new Divides(params));
        }
        catch (IllegalConstruction e) {
            return new MyNotANumber();
        }
    }

    // Rational number
    /**
     * Visit a rational number.
     *
     * @param ctx the parse tree
     * @return the resulting rational number
     */
    @Override
    public Expression visitRationalNumber(RationalExprParser.RationalNumberContext ctx) {
        int numerator = Integer.parseInt(ctx.integer(0).getText());
        int denominator = 1;
        if (ctx.FRAC() != null)
            denominator = Integer.parseInt(ctx.integer(1).getText());
        return new MyRationalNumber(numerator, denominator);
    }
}
